## 2024-08-05 : You Don't Know JS

> 2.4 함수 ~ 2.5.2 강제 변환

<br />

### NaN이나 -0과 비교연산자를 사용하면 예상과 다르게 동작합니다.

> 잘 쓰지 않는 NaN과 -0 비교라서 누군가 물어본다면 대답하지 못할 가능성이 높은 내용이라고 생각합니다.
> 

<br />

```jsx
NaN === NaN; // false
0 === -0; //true
```

`===`는 NaN과 다른 NaN은 같지 않다고 거짓말하고, -0과 0은 다른데 같다고 거짓말합니다.

그래서 === 연산자는 NaN 과 -0 과 함께 쓰지 않는 것이 최선입니다.

<br />

NaN과 비교할때는 거짓말을 하지 않는 Number.isNaN() 을 사용하고

-0과 비교할 때는 Object.is() 를 사용하는 것이 좋습니다.

Object.is()는 ==== 네개가 붙은 비교연산자라고 농담으로 불릴만큼 아주 정확히 비교해줍니다.

<br />

### **값(value) vs 참조(reference)**

> 알고있는 내용이지만 막상 코드를 짤 때 헷갈리거나 깜빡할 수 있어 실수할 가능성이 있는 부분이라고 생각합니다.    
이런 부분들 때문에 늘 기초를 다시 돌아보고 돌아봐야하는 이유라고 생각합니다.

값을 할당하거나 전달할 때 직접 **값 그 자체**를 할당/전달할지 아니면 **값의 참조**를 할당/전달 할 지 정합니다.

<br />

**원시 타입의 값을 할당 및 전달 하는 경우**

```jsx
var myName = "헤일리";
var yourName = myName;

myName = "주니";

console.log(myName); // 주니
console.log(yourName); // 헤일리
```

두 변수에는 독립적으로 복사된 값!이 저장되므로 값을 바꿔도 서로 영향을 받지 않습니다.

<br />

**반대로 참조는 Array, Function, Object 등의 객체값만 처리됩니다.**

```jsx
var x =[1,2,3];
var y = x; 

y === x; // true
y === [1,2,3] // false
x === [1,2,3] // false
```

JS에는 객체 구조가 같은지 비교할 방법이 없습니다.

JS에서는 같은 것을 참조하는지만 비교할 수 있습니다.

<br />

```jsx
var myAddress = {
	city: "서울특별시",
	country: "대한민국",
};
var yourAddress = myAddress;

myAddress.country = "일본";

console.log(yourAddress.country); // "일본" 
```

myAddress.city 만 변경했는데 참조한 yourAddress의 내용도 변경됩니다.

myAddress와 yourAddress에는 공유된 값인 객체에 대한 참조가 각각 복사되어 할당되므로 두 변수 중 하나만 수정해도 둘 다 갱신되는 효과가 있습니다.

<br />

---

<br />

> 값과 참조처럼 일하면서도 쓰는 것만 쓰게되서 이런 다시 처음으로 돌아보는 시간이 필요한 것 같다.